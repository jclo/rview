/*! Generated by Kadoo v1.2.0 */
// ESLint declarations
/* global define */
/* eslint no-shadow: ['error', { 'allow': ['root'] }] */
/* eslint strict: ["error", "function"] */
(function(root, factory) {
  'use strict';

  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([''], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    /* eslint-disable-next-line no-param-reassign */
    module.exports = factory(root);
  } else {
    // Browser globals.
    /* eslint-disable-next-line no-param-reassign */
    root.RView = factory(root);
  }
}(this, (root) => {
  'use strict';

  /* ***************************************************************************
   *
   * Tree is an object that links all the internal IIFE modules.
   *
   * ************************************************************************ */
  /* eslint-disable */
  let $__TREE = {"src":{"rview":{},"component":{"main":{},"extends":{},"hyperscript":{},"diffing":{},"config":{},"generic":{},"$":{},"animate":{},"add":{},"render":{},"setstate":{},"util":{}},"renderer":{"main":{}},"lib":{"_":{}},"plugin":{"main":{}}}};
  $__TREE.extend=function(o,m){var k=Object.keys(m);for(var i=0;i<k.length;i++){o[k[i]]=m[k[i]]}};
  /* - */
  /* eslint-enable */

  /* index: 1, path: 'src/rview.js', import: [2, 3, 4, 5, 6, 7, 8, 9] */
  (function() {
    /** ************************************************************************
     *
     * Defines the View object and its public method.
     *
     * View is the unique variable of this library that is exported outside
     * the library and thus accessible from the global windows. View implements
     * a method 'noconflict' to return the View variable to a previous owner if
     * any.
     *
     * rview.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Private Static Methods:
     *  . _setTestMode                returns internal objects for testing purpose,
     *
     *
     * Public Static Methods:
     *  . noConflict                  returns a reference to this RView object,
     *  . whoami                      returns the library name and version,
     *  . h                           converts the passed-in arguments to an object,
     *  . Component                   returns the extended View component,
     *  . render                      renders a View into the DOM,
     *  . restore                     restores the RView Component to its initial state,
     *  . remove                      removes the web component from the DOM,
     *  . plugin                      attaches a plugin,
     *  . makeid                      returns a new component id,
     *  . extends                     returns a new component inheriting from a parent,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const C = $__TREE.src.component.main;
    const CE = $__TREE.src.component.extends;
    const R = $__TREE.src.renderer.main;
    const { _ } = $__TREE.src.lib;
    const Hyperscript = $__TREE.src.component.hyperscript;
    const Differ = $__TREE.src.component.diffing;
    const P = $__TREE.src.plugin.main;
    const Config = $__TREE.src.component.config;


    // -- Local Constants
    // Saves the previous value of the library variable, so that it can be
    // restored later on, if noConflict is used.
    const previousRView = root.RView;


    // -- Local Variables


    // -- Main -----------------------------------------------------------------

    const RView = {

      // Useful to retrieve the library name and version when it is
      // embedded in another library as an object:
      _library: { name: 'RView', version: '1.2.0' },


      // -- Private Static Methods ---------------------------------------------

      /**
       * Returns the internal objects for testing purpose.
       * (must not be deleted)
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {Object}      returns a list of internal objects,
       * @since 0.0.0
       */
      _setTestMode() {
        return [_, C.Component, Hyperscript, Differ];
      },


      // -- Public Static Methods ----------------------------------------------

      /**
       * Returns a reference to this RView object.
       * (must not be deleted)
       *
       * Nota:
       * Running RView in no conflict mode, returns the RView variable to
       * its previous owner.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the RView object,
       * @since 0.0.0
       */
      noConflict() {
        /* eslint-disable-next-line no-param-reassign */
        root.RView = previousRView;
        return this;
      },

      /**
       * Returns the library name and version.
       * (must not be deleted)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the library name and version,
       * @since 0.0.0
       */
      whoami() {
        return this._library;
      },

      /**
       * Converts the passed-in arguments to an object.
       *
       * @method (...args)
       * @public
       * @param {...args}       arguments like { tag, attributes, value },
       * @returns {Object}      returns the object,
       * @since 0.0.0
       */
      h(...args) {
        return Hyperscript.format(...args);
      },

      /**
       * Returns the extended View component.
       *
       * @method (arg1)
       * @public
       * @param {Objects}       the specific properties of the created component,
       * @returns {Object}      returns the extented component function,
       * @since 0.0.0
       */
      Component(methods) {
        return C.Component(methods);
      },

      /**
       * Renders a View into the DOM.
       *
       * @method ([el, components, template])
       * @public
       * @param {}              -,
       * @returns {Object}      returns the root component object,
       * @since 0.0.0
       */
      render(options) {
        // options.el: '# . node', // could be an id, a class or a node element
        // options.components: { 'tag': { fn: ref, state: {}, props: {} } }
        // options.template: 'XMLString',
        return R.render(options);
      },

      /**
       * Restores the View Component to its initial state.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the rview object,
       * @returns {Boolean}     returns true if the restore succeeds,
       * @since 0.0.0
       */
      restore(rview) {
        return R.restore(rview);
      },

      /**
       * Removes the web component from the DOM and destroys the object.
       *
       * @method (arg1)
       * @public
       * @param {String}        the view object,
       * @returns {Boolean}     returns true if it succeeds,
       * @since 0.0.0
       */
      remove(rview) {
        return R.remove(rview);
      },

      /**
       * Attaches a plugin library.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the plugin library,
       * @returns {Boolean}     returns true if it succeeds,
       * @since 0.0.0
       */
      plugin(plug) {
        return P.plugin(plug);
      },

      /**
       * Returns a new component id.
       *
       * @method ([arg1])
       * @public
       * @param {}            -,
       * @returns {String}    returns a random string,
       * @since 0.0.0
       */
      makeid() {
        return _.makeid(Config.idLength);
      },

      /**
       * Returns a new component inheriting from a parent.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Function}    the parent component,
       * @param {Object}      the new or overwriting methods,
       * @returns {Function}  returns the new component,
       * @since 0.0.0
       */
      extends(parent, methods) {
        return CE.extends(parent, methods);
      },
    };

    // Attaches constants to RView that provide name and version of the lib.
    RView.NAME = 'RView';
    RView.VERSION = '1.2.0';


    // -- Export
    $__TREE.src.rview = RView;

    /* eslint-enable no-underscore-dangle */
  }());

  /* index: 2, path: 'src/component/main.js', import: [5, 10, 11] */
  (function() {
    /** ************************************************************************
     *
     * Defines the function that extends a child component from Generic and
     * returns the child component constructor.
     *
     * main.js is built upon the Prototypal Instantiation pattern. It
     * returns an object by calling its constructor. It doesn't use the new
     * keyword.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Constructor:
     *  . Component                   returns the child component constructor,
     *
     *
     *
     * Public Static Methods:
     *  . none,
     *
     *
     * Public Methods:
     *  . none,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;
    const Generic = $__TREE.src.component.generic;
    const Dollar = $__TREE.src.component.$;


    // -- Local Constants


    // -- Local Variables


    // -- Public ---------------------------------------------------------------

    /**
     * Returns the child component constructor.
     *
     * This function creates a child component that inherits from the Generic
     * component and extends the Generic component with its own methods.
     * Then, this function returns the child component constructor.
     *
     * @function (arg1)
     * @public
     * @param {Object}          the Child methods,
     * @returns {Function}      returns the child constructor,
     * @since 0.0.0
     */
    /* eslint-disable prefer-rest-params */
    function Component(methods) {
      let args;
      const Child = function() {
        if (this instanceof Child) {
          return Generic.Construct.apply(this, args);
        }
        args = arguments;
        return new Child();
      };

      // We created our own assign method as Object.assign does not preserve
      // the getters and setters. So, do not use Object.assign here! And, do not
      // do this 'Child.prototype = _.assign(Generic.methods, methods)'! You will
      // copy the references instead of cloning the methods. And all the childs
      // will get the methods of the last created child.
      const p1 = _.assign({}, Generic.methods);
      const p2 = _.assign(p1, { $: Dollar.$ });
      Child.prototype = _.assign(p2, methods || {});
      Child.prototype.constructor = Child;
      return Child;
    }
    /* eslint-enable prefer-rest-params */


    // -- Export
    $__TREE.extend($__TREE.src.component.main, { Component });

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 3, path: 'src/component/extends.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * A feature to create inheritance.
     *
     * extends.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _extends                     returns a Component inheriting from a parent,
     *
     *
     * Public Static Methods:
     *  . extends                     returns a Component inheriting from a parent,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Returns a new component inheriting from a parent.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Function}      the parent component,
     * @param {Object}        the new or overwriting methods,
     * @returns {Function}    returns the new component,
     * @since 0.0.0
     */
    /* eslint-disable prefer-rest-params */
    function _extends(parent, methods) {
      if (typeof parent !== 'function' || typeof parent.prototype.$hyperscript !== 'function') {
        return {
          erro_code: 'WrongComponent',
          message: 'the first argument is NOT a RView component!',
        };
      }

      if (Object.prototype.toString.call(methods) !== '[object Object]') {
        return {
          error_code: 'WrongValue',
          message: 'the second argument is NOT a literal object!',
        };
      }

      const Component = function() {
        let argu;
        const Child = function() {
          if (this instanceof Child) {
            return this._init(...argu);
          }
          argu = arguments;
          return new Child();
        };

        Child.prototype = Object.create(parent.prototype);
        Child.prototype.constructor = Child;
        Object.keys(methods).forEach((m) => {
          Child.prototype[m] = methods[m];
        });
        return Child;
      };

      return Component();
    }
    /* eslint-enable prefer-rest-params */


    // -- Public Static Methods ------------------------------------------------

    const Ex = {

      /**
       * Returns a new component inheriting from a parent.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Function}      the parent component,
       * @param {Object}        the new or overwriting methods,
       * @returns {Function}    returns the new component,
       * @since 0.0.0
       */
      extends(parent, methods) {
        return _extends(parent, methods);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.extends, Ex);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 4, path: 'src/renderer/main.js', import: [2, 5, 8] */
  (function() {
    /** ************************************************************************
     *
     * Implements the View methods to render and attach a component to the DOM.
     *
     * main.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _fireEvents                 fires the DOM events,
     *  . _attachMessenger            attaches the messenger object to all childs,
     *  . _format                     returns a formated XMLString (one element only),
     *  . _filter                     filters the parameters passed to View.render(),
     *  . _attachTemplateDOM          attaches the XML string to the DOM,
     *  . _remove                     removes the web component from the DOM,
     *  . _restore                    restores the View Component to its initial state.
     *  . _componenterize             transforms the selected node to a RView Component,
     *  . _render                     attaches the root comp and its childs to the DOM,
     *
     *
     * Public Static Methods:
     *  . render                      attaches the root comp and its childs to the DOM,
     *  . restore                     restores the View Component to its initial state,
     *  . remove                      removes the web component from the DOM,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules
    // import Messenger from '@mobilabs/messenger';


    // -- Local Modules
    const V = $__TREE.src.component.main;
    const { _ } = $__TREE.src.lib;
    const P = $__TREE.src.plugin.main;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Fires the DOM Events.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the child,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _fireEvents(co) {
      // Processes recursively cList to fire child events.
      if (co._cList) {
        const keys = Object.keys(co._cList);
        for (let i = 0; i < keys.length; i++) {
          co._cList[keys[i]].events();
          co._cList[keys[i]].listen();
          co._cList[keys[i]].postRender();
          _fireEvents(co._cList[keys[i]]);
        }
      }
    }

    /**
     * Attaches the messenger object to all childs.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the child,
     * @param {Object}          the messenger object,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _attachMessenger(co, mess) {
      // Processes recursively cList to attach the messenger object to
      // all the childs.
      if (co._cList) {
        const keys = Object.keys(co._cList);
        for (let i = 0; i < keys.length; i++) {
          /* eslint-disable-next-line no-param-reassign */
          co._cList[keys[i]]._mess = mess;
          _attachMessenger(co._cList[keys[i]], mess);
        }
      }
    }

    /**
     * Returns an XMLString that contains only one element with or without children.
     *
     * Nota:
     * The XMLString must represent an unique div, header or footer element with
     * childs. If it isn't the case surround the passed-in XMLString by a 'div'
     * and return it.
     *
     * @function (arg1)
     * @private
     * @param {XMLString}       the passed-in XMLString,
     * @param {XMLString}       the formated XMLString,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _format(xml) {
      const node = document.createElement('div');
      node.innerHTML = xml;
      if (node.children.length > 1) {
        return `<div>${xml}</div>`;
      }

      const firstChild = node.firstElementChild;
      if (!firstChild) {
        return '<div></div>';
      }

      const tag = firstChild.tagName.toLocaleLowerCase();
      if (tag !== 'div' && tag !== 'header' && tag !== 'footer') {
        return `<div>${xml}</div>`;
      }

      return xml;
    }

    /**
     * Filters the parameters passed to View.render().
     *
     * @function (arg1)
     * @private
     * @param {Object}          the required parameters,
     * @returns {Object}        the formatted parameters,
     * @since 0.0.0
     */
    function _filter(options) {
      const opt = { el: 'body', children: null, template: '<div></div>' };

      // Check if el is an id, a class or a node element:
      if (options.el) {
        if (_.isString(options.el)
          && (options.el.charAt(0) === '#' || options.el.charAt(0) === '.')) {
          opt.el = options.el;
        } else if (_.isObject(options.el) && options.el.namespaceURI) {
          opt.el = options.el;
        } else if (!options.silent) {
          /* eslint-disable-next-line no-console */
          console.log('warning: el must be an id, a class or a node element!');
        }
      }

      // Check if the template is a 'div', 'header' or 'footer' element. If not
      // surround it by a 'div'.
      if (_.isString(options.template)) {
        opt.template = _format(options.template);
      } else if (!options.silent) {
        /* eslint-disable-next-line no-console */
        console.log(
          'warning: template must be an XMLString starting with <div or <header or <footer!',
        );
      }

      // There is no need to check if children is properly formatted or not
      // as it is checked by the method component._renderer() before being
      // processed.
      opt.children = options.children;

      return opt;
    }

    /**
     * Attaches the XML string to the DOM.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the required parameters,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _attachTemplateDOM(opt) {
      const node = _.isString(opt.el) ? document.querySelector(opt.el) : opt.el;

      if (opt.el === 'body') {
        // Append to body:
        node.innerHTML += opt.template;
      } else {
        // Replace el childs if any:
        node.innerHTML = opt.template;
      }
    }

    /**
     * Removes the web component from the DOM and destroys the object.
     *
     * @function (arg1)
     * @private
     * @param {String}          the view object,
     * @returns {Boolean}       returns true if it succeeds,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign, no-proto */
    function _remove(view) {
      view.$().remove();
      Object.keys(view).forEach((key) => { delete view[key]; });
      view.__proto__ = {};
      return true;
    }
    /* eslint-enable no-param-reassign, no-proto */

    /**
     * Restores the View Component to its initial state.
     *
     * @function (arg1)
     * @private
     * @param {String}          the view object,
     * @returns {Boolean}       returns true if it succeeds,
     * @since 0.0.0
     */
    function _restore(view) {
      if (view && view._initialXMLNode) {
        const template = document.createElement('template');
        template.innerHTML = view._initialXMLNode;
        const iNode = template.content.firstChild;
        view.$()[0].parentNode.replaceChild(iNode, view.$()[0]);
        return true;
      }
      return false;
    }

    /**
     * Transforms the selected node to a RView Component.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the optional parameters,
     * @param {Object}          the reformatted optional parameters,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _componenterize(options, opt) {
      const { methods } = options || {}
          , Messenger   = P.get('messenger')
          ;

      // Check if the node exists in the DOM. if not return null.
      if (opt.el === 'body') return null;

      // Save the current node and retrieve the attributes:
      const node = _.isString(opt.el) ? document.querySelector(opt.el) : opt.el;
      const initialXMLNode = node.outerHTML;
      const id = node.getAttribute('id');
      const classList = node.className;
      const style = node.getAttribute('style');

      // Create a View.Component from the XML string (without id) of the
      // selected node. Then, replace the current node by the new generated
      // node in the DOM.
      // Extend the components methods with the passed-in methods, if any.
      const Comp = V.Component(_.extend(methods, {
        init() {
          this.state.class = classList || '';
          this.state.style = style || '';
          this.state.inside = '';
        },
        render(state) {
          return `
            <div class="${state.class}" style="${state.style}">${state.inside}</div>
          `;
        },
      }));
      const app = Comp();
      const xmlNewNode = app._renderer();
      const template = document.createElement('template');
      template.innerHTML = xmlNewNode;
      const newNode = template.content.firstChild;
      node.parentNode.replaceChild(newNode, node);

      // If the initial node has an id, replace the randowmly generated id by
      // the initial id.
      if (id) {
        newNode.setAttribute('id', id);
        app.id = id;
      }

      // Attach Messenger and the XML string of the initial node to 'app'
      // and return it.
      // The XML string of the initial node is saved because RView provides a
      // method RView.restore to returns the node to its initial state.
      app._mess = Messenger ? Messenger() : null;
      app._initialXMLNode = initialXMLNode;
      return app;
    }

    /**
     * Attaches the root component and its children to the DOM.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the parameters required to render the root component,
     * @returns {Object}        returns the root component object,
     * @since 0.0.0
     */
    function _render(options) {
      const opt       = _filter(options)
          , Messenger = P.get('messenger')
          ;

      if (!options.children && !options.template) {
        // If there is no children and no template, we componenterize the
        // selected node!
        return _componenterize(options, opt);
      }

      if (!opt.children) {
        // No components. Insert template only!
        _attachTemplateDOM(opt);
        return null;
      }

      // Ok. Create the root component and attach it to the DOM:
      const RootComp = V.Component({
        render() {
          this.name = 'firstparent';
          this.children = opt.children;
          return opt.template;
        },
      });
      const rootc = RootComp();
      opt.template = rootc._renderer();
      _attachTemplateDOM(opt);

      // Attach the messenger broker to the firstparent and all childs:
      rootc._mess = Messenger ? Messenger() : null;
      _attachMessenger(rootc, rootc._mess);

      // Now all the components are attached to the DOM, fire the DOM events
      // for each component:
      _fireEvents(rootc);

      // Returns the root component object.
      return rootc;
    }


    // -- Public Static Methods ------------------------------------------------

    const Renderer = {

      /**
       * Attaches the root component and its children to the DOM.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the parameters required to render the root component,
       * @returns {Object}      returns the root component object,
       * @since 0.0.0
       */
      render(params) {
        return _render(params);
      },

      /**
       * Restores the View Component to its initial state.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the rview object,
       * @returns {Boolean}     returns true if the restore succeeds,
       * @since 0.0.0
       */
      restore(rview) {
        return _restore(rview);
      },

      /**
       * Removes the web component from the DOM and destroys the object.
       *
       * @method (arg1)
       * @public
       * @param {String}        the rview object,
       * @returns {Boolean}     returns true if it succeeds,
       * @since 0.0.0
       */
      remove(rview) {
        return _remove(rview);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.renderer.main, Renderer);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 5, path: 'src/lib/_.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * Provides a set of utility functions.
     *
     * _.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Public Static Methods:
     *  . extend                      extends the passed-in object with new methods,
     *  . assign                      extends source with target(s),
     *
     *  . isString                    is a given value a string?
     *  . isNumber                    is a given value a number?
     *  . isObject                    is a given variable an object?
     *  . isLiteralObject             is a given variable a literal object?
     *  . isFunction                  is a given variable a function?
     *  . isArray                     is a given value an array?
     *  . _makeid                     returns a unique string pattern,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Public Static Methods ------------------------------------------------

    const _ = {

      /**
       * Extends the passed-in object with new methods.
       *
       * Nota: this function mutates object.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the object to extend,
       * @param {Object}        an object containing a set of methods,
       * @returns {}            -,
       * @since 0.0.0
       */
      extend(object, methods) {
        const keys = Object.keys(methods);

        for (let i = 0; i < keys.length; i++) {
          /* eslint-disable-next-line no-param-reassign */
          object[keys[i]] = methods[keys[i]];
        }
        return object;
      },

      /**
       * Extends source with target(s) while preserving the assessors.
       *
       * Nota:
       * Clones a literal object at the first level while preserving the
       * assessors (get and set). This should be the prefered method to Clones
       * a literal object or a prototype that includes get and set assessors.
       *
       * Example:
       * To clone a function prototype:
       * var a = _.assign({}, fn.prototype);  // clone the original prototype,
       * _.assign(fn2.prototype, a);          // assign it to fn2.prototype,
       *
       * @method (...arg1)
       * @public
       * @param {Object}        the objects to 'fusion',
       * @returns {Object}      returns the reassigned object,
       * @since 0.0.0
       */
      /* eslint-disable no-param-reassign, no-loop-func, prefer-rest-params */
      assign() {
        const target = arguments[0];
        let source
          , descriptors
          , i
          ;

        for (i = 1; i < arguments.length; i++) {
          source = arguments[i];
          descriptors = Object.keys(source).reduce((props, key) => {
            props[key] = Object.getOwnPropertyDescriptor(source, key);
            return props;
          }, {});
        }
        Object.defineProperties(target, descriptors);
        return target;
      },
      /* eslint-enable no-param-reassign, no-loop-func, prefer-rest-params */


      // -- Subset of Overslash ------------------------------------------------

      /**
       * Is a given value a string?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isString(obj) {
        return Object.prototype.toString.call(obj) === '[object String]';
      },

      /**
       * Is a given value a number?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isNumber(obj) {
        return Object.prototype.toString.call(obj) === '[object Number]';
      },

      /**
       * Is a given variable an object?
       * (copied from: http://underscorejs.org)
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isObject(obj) {
        const type = typeof obj;
        return (type === 'function' || type === 'object') && !!obj;
      },

      /**
       * Is a given variable a literal object?
       *
       * @method (arg1)
       * @private
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.3
       */
      isLiteralObject(obj) {
        return Object.prototype.toString.call(obj) === '[object Object]';
      },

      /**
       * Is a given variable a function?
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isFunction(obj) {
        return Object.prototype.toString.call(obj) === '[object Function]';
      },

      /**
       * Is a given value an array?
       * (Delegates to ECMA5's native Array.isArray.)
       * (copied from: http://underscorejs.org)
       *
       * @method (arg1)
       * @public
       * @param {Object}        the object to test,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      isArray(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
      },

      /**
       * Returns a unique string pattern with a predefined length.
       *
       * @method ([arg1])
       * @public
       * @param {Number}      the length of the string. Default is 16 chars,
       * @returns {String}    returns a random string from the charset defined in c,
       * @since 0.0.0
       */
      makeid(l) {
        const ll = this.isNumber(l) ? l : 16
            , cm = 'ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghijklmnopqrstuvwxyz'
            , c  = `0123456789${cm}`
            ;

        let id = cm.charAt(Math.floor(Math.random() * cm.length));
        for (let i = 0; i < (ll - 1); i++) {
          id += c.charAt(Math.floor(Math.random() * c.length));
        }
        return id;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.lib._, _);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 6, path: 'src/component/hyperscript.js', import: [5] */
  (function() {
    /** ************************************************************************
     *
     * Converts an hyperscript object to a node element.
     *
     * hyperscript.js is just a literal object that contains a set of functions.
     * It can't be intantiated.
     *
     * Private Functions:
     *  . _reshuffle                  rebuilds the component tags,
     *  . _stringify                  returns the attribute value converted to a string,
     *  . _render                     converts an hyperscript object to a node element,
     *
     *
     * Public Static Methods:
     *  . format                      converts the passed-in arguments to an object,
     *  . render                      converts an hyperscript object to an XMLString,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Rebuilds the component tags.
     *
     * Nota:
     * When serialized the component tags become '<cxx></cxx>'. We reformat them
     * as it should be, i.e. '<Cxx />'. Besides, we update 'cList' to link
     * the component tag to the component object ({ '<Cxx />': Cxx }).
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {String}          the serialized node,
     * @param {Object}          the cList object,
     * @param {Object}          the local cList object,
     * @returns {String}        returns the reformatted serialized node,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _reshuffle(node, cList, locList) {
      const keys = Object.keys(locList)
          ;

      for (let i = 0; i < keys.length; i++) {
        node = node
          .replace(`</${keys[i].toLowerCase()}>`, '')
          .replace(keys[i].toLowerCase(), `${keys[i]} /`);

        cList[`<${keys[i]} />`] = locList[keys[i]];
      }
      return node;
    }
    /* eslint-enable no-param-reassign */

    /**
     * Returns the attribute value converted to a string.
     *
     * Nota:
     * This function converts a style attribute like this:
     *  . style: { 'font-family': 'helvetica', 'font-size': '20px' }
     *
     * @function (arg1)
     * @private
     * @param {Object}          the attribute value,
     * @returns {String}        returns a string of the attribute value,
     * @since 0.0.0
     */
    function _stringify(attr) {
      const keys = Object.keys(attr)
          ;

      let s = '';
      for (let i = 0; i < keys.length; i++) {
        s += i < keys.length - 1
          ? `${keys[i]}: ${attr[keys[i]]}; `
          : `${keys[i]}: ${attr[keys[i]]};`;
      }
      return s;
    }

    /**
     * Converts an hyperscript object to a node element.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the hyperscript object,
     * @param {Object}          the local version of cList to link a tag to a component,
     * @returns {Object}        the node representation,
     * @since 0.0.0
     */
    function _render(vnode, locList) {
      const { nodeName } = vnode
          , { attributes } = vnode
          , { children } = vnode
          ;

      let el
        , keys
        , value
        , obj
        , id
        , i
        ;

      // Checks if vnode is a string. If it is the case, it means that this node
      // is in fact a text node. So, we return the created element text node.
      if (_.isString(vnode)) {
        return document.createTextNode(vnode);
      }

      // nodeName could be an HTML tag, an hyperscript node or a Component.
      switch (typeof nodeName) {
        // nodeName is an HTML tag. We create a node element from this tag and
        // we attach the attributes defined by 'attributes'. The 'attributes'
        // could be a value or an object if this attribute is a style.
        case 'string':
          el = document.createElement(nodeName);
          keys = attributes ? Object.keys(attributes) : [];
          for (i = 0; i < keys.length; i++) {
            value = _.isObject(attributes[keys[i]])
              ? _stringify(attributes[keys[i]])
              : attributes[keys[i]];
            el.setAttribute(keys[i], value);
          }
          break;

        // 'nodeName' is a function. It could be an hyperscript object or a sub
        // 'component'. If the object returned by the executed function nodeName
        // has the method 'render', it is a component otherwise it is an
        // hyperscript object.
        case 'function':
          obj = nodeName();
          if (obj.render) {
            // We do not process subcomponents otherwise they are merged with
            // the current node and we can't access them independently. Thus,
            // we create a tag ('<Cxx />') instead and this Component is processed
            // independently so it inherits of an unique id and a reference in cList.
            // If the name isn't provided, we create an unique identifier for this
            // subcomponent but it becomes then difficult to access it.
            id = attributes && attributes.name
              ? attributes.name
              : `C${Math.random().toString(36).substr(2, 7)}`;
            /* eslint-disable-next-line no-param-reassign */
            locList[id] = {
              fn: nodeName,
              state: attributes.state ? attributes.state : null,
              props: attributes.props ? attributes.props : null,
            };
            el = _render({ nodeName: id, attributes: null, children: [] }, locList);
          } else {
            // We process recursively the hyperscript objects.
            el = _render(obj, locList);
          }
          break;

        default:
          throw new Error(
            `hypserscript._render: nodeName is a ${typeof nodeName} ???`,
          );
      }

      // Recursively processes all of its children:
      for (i = 0; i < children.length; i++) {
        el.appendChild(_render(children[i], locList));
      }

      return el;
    }


    // -- Public Static Methods ------------------------------------------------

    const Hyperscript = {

      /**
       * Converts the passed-in arguments to an object.
       *
       * @method (...args)
       * @public
       * @param {...args}       arguments like { tag, attributes, value },
       * @returns {Object}      returns the object,
       * @since 0.0.0
       */
      format(...args) {
        const [nodeName, attributes, ...children] = args;
        return { nodeName, attributes, children };
      },

      /**
       * Converts an hyperscript object to a node and returns its string representation.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the hyperscript object,
       * @param {Object}        the cList object,
       * @returns {String}      returns the string represention of the hyperscript object,
       * @since 0.0.0
       */
      render(vnode, cList) {
        const s = new XMLSerializer()
            , locList = {}
            ;

        const node = s.serializeToString(_render(vnode, locList))
          .replace('xmlns="http://www.w3.org/1999/xhtml"', '');
        return _reshuffle(node, cList, locList);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.hyperscript, Hyperscript);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 7, path: 'src/component/diffing.js', import: [9] */
  (function() {
    /** ************************************************************************
     *
     * Updates a DOM node with the passed in 'virtual' node.
     *
     * It updates only the elements that have attributes or contents that
     * differ from the passed-in HTML node.
     *
     * diff is free interpretation of:
     *  - https://gomakethings.com/dom-diffing-with-vanilla-js/
     *
     * diffing.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _stringToHTML               converts an XML String to an HTML object,
     *  . _getNodeType                returns the tag name,
     *  . _getNodeContent             returns the element content,
     *  . _updateAttributes           updates the target attrs to match the source attrs,
     *  . _diff                       updates the outdated elements of the DOM node,
     *
     *
     * Public Static Methods:
     *  . stringToHTML                converts an XML String to an HTML object,
     * . diff                         updates the outdated elements of the DOM node,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const C = $__TREE.src.component.config;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Converts an XML String to an HTML object.
     *
     * @function (arg1)
     * @private
     * @param {XMLString}       the XML string to convert,
     * @returns {Object}        returns the HTML object,
     * @since 0.0.0
     */
    function _stringToHTML(str) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(str, 'text/html');
      return doc.body.firstChild;
    }

    /**
     * Returns the tag name.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the node,
     * @returns {String}        returns the tag name,
     * @since 0.0.0
     */
    function _getNodeType(node) {
      if (node.nodeType === 3) return 'text';
      if (node.nodeType === 8) return 'comment';
      return node.tagName.toLowerCase();
    }

    /**
     * Returns the element content.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the node,
     * @returns {String}        returns the element content,
     * @since 0.0.0
     */
    function _getNodeContent(node) {
      if (node.childNodes && node.childNodes.length > 0) return null;
      return node.textContent;
    }

    /**
     * Updates the target attributes to match the source attributes.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the reference element,
     * @param {Object}          the DOM element,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _updateAttributes(node, elem) {
      const nodeAttrs = node.getAttributeNames();
      const elemAttrs = elem.getAttributeNames();

      // Parse all the source attributes and update the target attributes
      // accordingly.
      for (let i = 0; i < nodeAttrs.length; i++) {
        const nodeAttr = nodeAttrs[i];
        const elemAttr = elem.attributes.getNamedItem(nodeAttr);
        const nodeAttrValue = node.getAttribute(nodeAttr);
        const elemAttrValue = elem.getAttribute(nodeAttr);
        if (!elemAttr || (elemAttrValue !== nodeAttrValue)) {
          // Ok the DOM element hasn't the attribute or its value is
          // outdated, set it:
          // console.log(`set attribute: ${nodeAttr} with the value: ${nodeAttrValue}`);
          elem.setAttribute(nodeAttr, nodeAttrValue);
        }
      }

      // Remove the extra target attributes.
      for (let i = 0; i < elemAttrs.length; i++) {
        if (nodeAttrs.indexOf(elemAttrs[i]) === -1) {
          // console.log(`${elemAttrs[i]} is an extra attribute!`);
          elem.removeAttribute(elemAttrs[i]);
        }
      }
    }

    /**
     * Updates the outdated elements of the DOM node.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the reference node,
     * @param {Object}          the DOM node,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _diff(source, target) {
      // Get arrays of children nodes
      const sourceNodes = Array.prototype.slice.call(source.childNodes);
      const domNodes = Array.prototype.slice.call(target.childNodes);

      // If there are extra elements in DOM, remove them
      let count = domNodes.length - sourceNodes.length;
      if (count > 0) {
        // console.log('remove extra nodes!');
        for (; count > 0; count--) {
          /* eslint-disable-next-line max-len */
          domNodes[domNodes.length - count].parentNode.removeChild(domNodes[domNodes.length - count]);
        }
      }

      // Diff each item in the templateNodes
      sourceNodes.forEach((node, index) => {
        if (_getNodeType(node) === 'div'
            && node.hasAttribute('id') && node.getAttribute('id').length === C.idLength
            && domNodes[index]) {
          // if the attribute is a RView child component we don't explore it.
          // Diffing only checks the difference between the component and the
          // DOM for the given component excluding the childs components. The goal
          // is to not interfere with a child component own updating mechanism.
          // If it doesn't exist in the DOM, it is an anchor for an external
          // component, so we add it to the DOM.
          return;
        }

        // If the element doesn't exist in the DOM, create it:
        if (!domNodes[index]) {
          // console.log('add a node!');
          target.appendChild(node.cloneNode(true));
          return;
        }

        // If element is not the same type, replace it with the new element:
        if (_getNodeType(node) !== _getNodeType(domNodes[index])) {
          // console.log(`replace node ${_getNodeType(node)} by ${_getNodeType(domNodes[index])}`);
          domNodes[index].parentNode.replaceChild(node.cloneNode(true), domNodes[index]);
          return;
        }

        // If the content is different, update it:
        const sourceContent = _getNodeContent(node);
        if (sourceContent && sourceContent !== _getNodeContent(domNodes[index])) {
          // console.log('update content');
          domNodes[index].textContent = sourceContent;
        }

        // If the attributes are different update them:
        const type = _getNodeType(node);
        if (type !== 'text' && type !== 'comment'
          && (node.hasAttributes() || domNodes[index].hasAttributes())) {
          _updateAttributes(node, domNodes[index]);
        }

        // If the target element should be empty, wipe it
        if (domNodes[index].childNodes.length > 0 && node.childNodes.length < 1) {
          // console.log('empty target element');
          domNodes[index].innerHTML = '';
          return;
        }

        // If element is empty and shouldn't be, build it up.
        // This uses a document fragment to minimize reflows
        if (domNodes[index].childNodes.length < 1 && node.childNodes.length > 0) {
          const fragment = document.createDocumentFragment();
          _diff(node, fragment);
          // console.log('append fragment');
          domNodes[index].appendChild(fragment);
          return;
        }

        // If there are existing child elements that need to be modified, diff them
        if (node.childNodes.length > 0) {
          // console.log(node);
          _diff(node, domNodes[index], true);
        }
      });
    }


    // -- Public Static Methods ------------------------------------------------

    const Differ = {

      /**
       * Converts an XML String to an HTML object.
       *
       * @method (arg1)
       * @public
       * @param {XMLString}     the XML string to convert,
       * @returns {Object}      returns the HTML object,
       * @since 0.0.0
       */
      stringToHTML(str) {
        return _stringToHTML(str);
      },

      /**
       * Updates the outdated elements of the DOM node.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the reference node,
       * @param {Object}        the DOM node,
       * @since 0.0.0
       */
      diff(source, target) {
        _diff(source, target);

        // 'diff' processes the children of the source and target only. If the
        // attributes of the source element have been modified we need to update
        // the target element.
        _updateAttributes(source, target);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.diffing, Differ);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 8, path: 'src/plugin/main.js', import: [5] */
  (function() {
    /** ************************************************************************
     *
     * Manages the plugin.
     *
     * main.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Public Static Methods:
     *  .
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules
    const { _ } = $__TREE.src.lib;


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Attaches a valid plugin.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the plugin db,
     * @param {Function}        the plugin library,
     * @returns {Boolean}       returns true if it succeeds,
     * @since 0.0.0
     */
    function _plugin(db, plug) {
      if (_.isLiteralObject(plug)
        && plug.messenger && plug.messenger.NAME === 'Messenger') {
        /* eslint-disable-next-line no-param-reassign */
        db.messenger = plug.messenger;
        return true;
      }
      return false;
    }


    // -- Public Static Methods ------------------------------------------------

    const Plugin = {

      /**
       * The plugin db
       */
      _db: {
        messenger: null,
      },

      /**
       * Attaches a valid plugin.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the plugin library,
       * @returns {Boolean}     returns true if it succeeds,
       * @since 0.0.0
       */
      plugin(plug) {
        return _plugin(this._db, plug);
      },

      /**
       * Returns the requested plugin.
       *
       * @method (arg1)
       * @public
       * @param {String}        the plugin name,
       * @returns {Function}    returns the requested plugin,
       * @since 0.0.0
       */
      get(plugin) {
        return _.isString(plugin) && this._db[plugin] ? this._db[plugin] : null;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.plugin.main, Plugin);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 9, path: 'src/component/config.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * A set of configuration parameters.
     *
     * config.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . none
     *
     *
     * Public Static Methods:
     *  . none,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Public ---------------------------------------------------------------

    const Config = {

      // the length of the component id:
      idLength: 8,
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.config, Config);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 10, path: 'src/component/generic.js', import: [5, 12, 13, 14, 6, 15, 16, 9] */
  (function() {
    /** ************************************************************************
     *
     * Defines the generic component. All the created components extend this
     * component.
     *
     * generic.js is built upon the Prototypal Instantiation pattern. It
     * returns an object by calling its constructor. It doesn't use the new
     * keyword.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Constructor:
     *  . Construct                   constructor,
     *
     *
     * Private Variables
     *  . _tag                        constains the tag string of the component,
     *  . _cList                      contains the list of children objects,
     *  . _mess                       the messenger object,
     *
     * Private Methods:
     *  . _init                       executes the private init when the comp. is created,
     *  . _renderer                   renders the component an its children, return XML,
     *  . _render                     returns data returned by the public method render,
     *
     *
     * Public Variables:
     *  . id                          unique id of the component (read only),
     *  . children                    list of the children components,
     *  . state                       component state properties,
     *  . props                       component properties,
     *  . name                        name of the component,
     *
     *
     * Public Methods:
     *  . $                           returns an object to manipulate the comp. in the DOM,
     *  . $animate                    animates the component,
     *  . $abortAnimation             aborts the running animation,
     *  . $append                     appends a component as the last child,
     *  . $getChild                   returns a component object,
     *  . $removeChild                removes a child,
     *  . $getChildren                returns the list of the children,
     *  . $getIdAndName               returns the component's Id and name,
     *  . $hyperscript                returns an XML string of the hyperscript template,
     *  . $setState                   updates state value(s),
     *  . $listen                     listens a message,
     *  . $emit                       sends a message,
     *
     *
     * Empty Public Methods:
     *  . init                        executes the public initializations,
     *  . events                      processes the DOM events,
     *  . listen                      listens the DOM events,
     *  . postRender                  executes operations after component added to DOM,
     *  . onChange                    executes operations after component updated in DOM,
     *  . render                      returns the component XML string,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;
    const A = $__TREE.src.component.animate;
    const AD = $__TREE.src.component.add;
    const R = $__TREE.src.component.render;
    const H = $__TREE.src.component.hyperscript;
    const S = $__TREE.src.component.setstate;
    const Util = $__TREE.src.component.util;
    const C = $__TREE.src.component.config;


    // -- Local Constants


    // -- Local Variables


    // -- Public ---------------------------------------------------------------

    /**
     * Defines the Generic Component constructor.
     *
     * @constructor (...args)
     * @public
     * @param {}                -,
     * @returns {}              -,
     * @since 0.0.0
     */
    function Construct() {
      /* eslint-disable-next-line prefer-spread, prefer-rest-params */
      this._init.apply(this, arguments);
    }


    const methods = {


      // -- Private Methods ----------------------------------------------------

      /**
       * Does the initializations when the component is created.
       *
       * @method (arg1)
       * @private
       * @param {Object}        the options,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      _init(...args) {
        // init private:
        this._tag = null;
        this._cList = null;
        this._mess = null;

        // init public:
        // Creates an unique id for this component:
        // this.id = `i${Math.random().toString(36).substr(2, 7)}`;
        this.id = _.makeid(C.idLength);
        this.children = null;

        const [state, props] = args;
        this.state = _.isLiteralObject(state) ? state : {};
        this.props = _.isLiteralObject(props) ? props : {};
        this.name = 'mynameisnobody';

        // Call the public init:
        this.init();
        return this;
      },

      /**
       * Renders the component and returns its XMLString.
       * (must not be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {XMLString}   returns the component's XMLString,
       * @since 0.0.0
       */
      _renderer() {
        return R.render(this);
      },

      /**
       * Returns data returned by the public method render.
       * (must not be overwritten)
       *
       * @method ([arg1], [arg2])
       * @public
       * @param {Object}        the state properties,
       * @param {Object}        the optional properties,
       * @returns {XMLString}   returns the component's XMLString,
       * @since 0.0.0
       */
      _render(...args) {
        /*
        xml = xml.replace(/<!--(.*?)-->/g, '')    // remove comments
          .replace(/\n\s+</g, '\n<')              // remove leading spaces before a tag,
          .replace(/\n<\/div>/g, '</div>')        // remove unwanted `\n`,
          .replace(/\n<\/ul>/g, '</ul>')          // -
          .replace(/\n<\/li>/g, '</li>')          // -
          .replace(/\n<\/a>/g, '</a>')            // -
        ;
        */
        const xml = this.render(...args);
        if (_.isString(xml)) {
          return xml.trim();
        }
        return xml;
      },


      // -- Defined Public Methods ---------------------------------------------

      /**
       * Returns an object to manipulate the component in the DOM.
       * (must not be overwritten - see implementation in $.js)
       *
       * Nota: $ is filled when the View.Component is created
       * (see main.js constructor).
       *
       * @method (arg1)
       * @public
       * @param {String}        the node selector (id or class),
       * @returns {Object}      returns the $ object,
       * @since 0.0.0
       */
      $: null,

      /**
       * Animates the component.
       * (must not be overwritten)
       *
       * @method (...args)
       * @public
       * @param {...args}       properties [, duration ] [, easing ] [, callback ],
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $animate(...args) {
        [this._anim_timer, this._anim_callback] = A.animate(this, ...args);
        return this;
      },

      /**
       * Aborts the running animation.
       * (must not be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $abortAnimation() {
        A.abortAnimation(this._anim_timer, this._anim_callback);
        return this;
      },

      /**
       * Appends a component as the last child to the selected component.
       * (must not be overwritten)
       *
       * @method (...args)
       * @public
       * @param {...args}       tag, component, [state], [props]
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $append(...args) {
        AD.append(this, ...args);
        return this;
      },

      /**
       * Returns a component object.
       * (must not be overwritten)
       *
       * Nota:
       * the algorithm tests 'ident' in this order: tag, id, name. It
       * explores by parsing entirely the first child branch before parsing the
       * second child branch. I stops as soon as there is a match.
       *
       * So, if a child in the second child branch as the same tag or name as a
       * child in the first child branch, the algorithm returns the child in the
       * first branch only. The matching child on the second branch won't never be
       * retrieved.
       *
       * So, avoid duplicating tag or name.
       *
       * @method (arg1)
       * @public
       * @param {String}        the component identity (could be tag, id or name),
       * @returns {Object}      returns the component object or null,
       * @since 0.0.0
       */
      $getChild(ident) {
        return Util.getChild(this, ident);
      },

      /**
       * Remove a component's child.
       * (must not be overwritten)
       *
       * @method (arg1)
       * @public
       * @param {String}        the component identity (could be tag, id or name),
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      $removeChild(ident) {
        return Util.removeChild(this, ident);
      },

      /**
       * Returns the list of children.
       * (must not be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Array}       returns the children list or null,
       * @since 0.0.0
       */
      $getChildren() {
        return Util.getChildren(this);
      },

      /**
       * Returns the component's Id and name.
       * (must not be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the component's id and name,
       * @since 0.0.0
       */
      $getIdAndName() {
        return { id: this.id, name: this.name };
      },

      /**
       * Returns an XMLString representation of the hyperscript template.
       * (must not be overwritten)
       *
       * @method (...args)
       * @public
       * @param {...}           arguments like { tag, attributes, value },
       * @returns {Object}      returns an object containing the node, its attributes
       * @since 0.0.0           and the children,
       */
      $hyperscript(...args) {
        return H.format(...args);
      },

      /**
       * Updates state value(s).
       * (must not be overwritten)
       *
       * @method (arg1)
       * @public
       * @param {Object}        the state object,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $setState(params) {
        if (_.isLiteralObject(params)) {
          S.setState(this, params);
        }
        return this;
      },

      /**
       * Listens for a message from another component.
       * (must not be overwritten)
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the event to listen,
       * @param {Function}      the listener to attach to this event,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $listen(event, listener) {
        if (this._mess) {
          this._mess.subscribe(event, listener);
          return this;
        }
        /* eslint-disable-next-line no-console */
        console.log('$listen: the plugin Messenger is not installed!');
        return this;
      },

      /**
       * sends for a message to another component.
       * (must not be overwritten)
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the event to listen,
       * @param {Object}        the payload to send,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $emit(event, payload) {
        if (this._mess) {
          this._mess.publish(event, payload);
          return this;
        }
        /* eslint-disable-next-line no-console */
        console.log('$emit: the plugin Messenger is not installed!');
        return this;
      },


      // -- Empty Public Methods -----------------------------------------------

      /**
       * Does the initializations when the component is created.
       * (could be overwritten)
       *
       * Nota:
       * 'props.options' are initialized when the component is instantiated. Be
       * careful not to overwrite it.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      init() {
        return this;
      },

      /**
       * Processes the DOM events.
       * (could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      events() {
        return this;
      },

      /**
       * Listens the DOM events.
       * (could be overwritten)
       *
       * Nota:
       * This method is called after the component
       * has been attached to the DOM. It must be used
       * to listen to the DOM events generated by the component.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      listen() {
        return this;
      },

      /**
       * Executes operations after component added to DOM.
       * (could be overwritten)
       *
       * Nota:
       * This method is called after the component
       * has been attached to the DOM. It must be used
       * to perform a post-rendering process.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      postRender() {
        return this;
      },

      /**
       * Executes operations after component updated in DOM.
       * (could be overwritten)
       *
       * Nota:
       * This method is called after the component, already
       * in the DOM, is updated through a $setState. It must be used
       * to perform a post-rendering process after each update.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      onChange() {
        return this;
      },

      /**
       * Returns an XMLString.
       * (could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {String}      returns XMLString,
       * @since 0.0.0
       */
      render() {
        return '<div></div>';
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.generic, { Construct, methods });

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 11, path: 'src/component/$.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * Implements the methods to manipulate the DOM.
     *
     * $.js is just an object that contains a set of methods. It implements the
     * factory pattern. Thus, $(sel) returns the selected node and the methods
     * listed below.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Public Variables:
     *  . id                          the id of selected element,
     *  . [0]                         the selected DOM element,
     *  . _root                       the first parent element,
     *
     *
     * Constructor:
     *  . $                           creates the component,
     *
     *
     * Public Methods:
     *  . select                      selects a child element,
     *  . selectChild                 selects the nth child,
     *  . parent                      returns to the parent element,
     *  . firstParent                 returns to the root parent if defined,
     *
     *  . find                        returns the NodeList of the matching children,
     *  . tag                         returns the tag name of the selected element,
     *
     *  . innerHTML                   returns the value of an element as an XMLString,
     *  . outerHTML                   returns an element as an XMLString,
     *  . text                        gets the text contents of the element,
     *
     *  . firstChild                  returns the firstChild element,
     *  . children                    returns the children,
     *  . childIndex                  returns the children position in the parent tree,
     *  . getBoundingClientRect       returns the DOMRect object that bounds,
     *
     *  . css                         gets the style attribute of the element,
     *
     *  . getClassList                returns the DOMTokenList collection,
     *  . hasClass                    checks if the element has the passed-in class,
     *
     *  . attr                        gets the specified attribute,
     *
     *  . on                          attachs an event listener to the current node,
     *  . off                         removes an event listener from the current node,
     *  . trigger                     fires the event associated to the selected node,
     *
     *  . remove                      removes the element from the DOM,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Public Methods -------------------------------------------------------

    function $(selector) {
      const cid = this.id;
      let el
        , el0
        ;

      /**
       * Select a child element.
       *
       * @method (arg1)
       * @public
       * @param {String}        the selector,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      const select = function(sel) {
        if (typeof sel === 'string' && this[0]) {
          const child = this[0].querySelector(sel);
          if (child) {
            this[0] = child;
          }
        }
        return this;
      };

      /**
       * Selects the specified child if it exists.
       *
       * @method (arg1)
       * @public
       * @param {Number}        the child index,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      const selectChild = function(n) {
        if (Object.prototype.toString.call(n) === '[object Number]') {
          this[0] = this[0].children[n] ? this[0].children[n] : this[0];
        }
        return this;
      };

      /**
       * Returns to the parent element.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      const parent = function() {
        if (this._root) {
          // As a root parent is defined, we stop at it.
          if (this[0] !== this._root) {
            this[0] = this[0].parentNode;
          }
        } else {
          this[0] = this[0].parentNode;
        }
        return this;
      };

      /**
       * Returns to the root parent if defined.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      const firstParent = function() {
        if (this._root) {
          this[0] = this._root;
        }
        return this;
      };

      /**
       * Returns the NodeList of the matching children.
       *
       * @method (arg1)
       * @public
       * @param {String}        the selector,
       * @returns {Array}       returns the NodeList,
       * @since 0.0.0
       */
      const find = function(sel) {
        return this[0].querySelectorAll(sel);
      };

      /**
       * Returns the tag name of the selected element.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {String}      returns the tag name,
       * @since 0.0.0
       */
      const tag = function() {
        if (this[0]) {
          return this[0].tagName;
        }
        return null;
      };

      /**
       * Returns the value of an element as an XMLString.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {String}      returns the XMLString,
       * @since 0.0.0
       */
      const innerHTML = function() {
        return this[0].innerHTML;
      };

      /**
       * Returns an element as an XMLString.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {}            returns the XMLString,
       * @since 0.0.0
       */
      const outerHTML = function() {
        return this[0].outerHTML;
      };

      /**
       * Gets the text contents of the element,
       *
       * @method (arg1)
       * @public
       * @param {String}        the text contents to add,
       * @returns {String}      returns the text contents or this;,
       * @since 0.0.0
       */
      const text = function() {
        return this[0].textContent;
      };

      /**
       * Returns the firstChild.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the firstChild,
       * @since 0.0.0
       */
      const firstChild = function() {
        return this[0].firstElementChild;
      };

      /**
       * Returns the children.
       *
       * @method ()
       * @public
       * @param {}            -,
       * @returns {Object}    returns the children HTMLCollection,
       * @since 0.0.8
       */
      const children = function() {
        return this[0].children;
      };

      /**
       * Returns the children position in the parent tree.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the children position,
       * @since 0.0.8
       */
      const childIndex = function() {
        let child = this[0]
          , index = 0
          ;

        while (child !== null) {
          child = child.previousElementSibling;
          index += 1;
        }
        return index - 1;
      };

      /**
       * Returns the DOMRect object that bounds the contents of the range.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the DOMRect object,
       * @since 0.0.8
       */
      const getBoundingClientRect = function() {
        return this[0] ? this[0].getBoundingClientRect() : null;
      };

      /**
       * Gets/Sets the style attribute of the element,
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the style attribute,
       * @param {String}        the style attribute value,
       * @returns {String}      returns the style attribute value or this,
       * @since 0.0.0
       */
      const css = function(styleAttr) {
        const arr = typeof styleAttr === 'string' ? styleAttr.split('-') : [];
        let attr = '';

        // Convert style attribute name with '-' (ex.: 'font-size' to 'fontSize'):
        for (let i = 0; i < arr.length; i++) {
          if (i === 0) {
            attr += arr[i];
          } else {
            attr += arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
          }
        }
        return this[0].style[attr];
      };

      /**
       * Returns the DOMTokenList collection of the class attributes of the element.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the DOMTokenList of the element,
       * @since 0.0.0
       */
      const getClassList = function() {
        return this[0].classList;
      };

      /**
       * Checks if the element has the passed-in class.
       *
       * @method (arg1)
       * @public
       * @param {String}        the class name,
       * @returns {Boolean}     returns true or false,
       * @since 0.0.8
       */
      const hasClass = function(className) {
        const list = this[0].classList.value.split(' ');

        if (Object.prototype.toString.call(className) === '[object String]' && list.indexOf(className) !== -1) {
          return true;
        }
        return false;
      };

      /**
       * Gets the specified attribute.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the attribute name,
       * @param {String}        the attribute value,
       * @returns {String}      returns the attribute value or this,
       * @since 0.0.0
       */
      const attr = function(attribute) {
        return this[0].getAttribute(attribute);
      };

      /**
       * Attachs an event listener to the current node.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the DOM event string,
       * @param {Function}      the listner function,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      const on = function(event, listener) {
        this[0].addEventListener(event, listener);
        return this;
      };

      /**
       * Removes an event listener from the current node.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the DOM event string,
       * @param {Function}      the listner function,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      const off = function(event, listener) {
        this[0].removeEventListener(event, listener);
        return this;
      };

      /**
       * Fires the event associated to the selected node.
       *
       * @method (arg1)
       * @public
       * @param {String/Object} the event name or the event object,
       * @returns {Boolean}     returns false if preventDefault was activated
       * @since 0.0.0           otherwise true,
       */
      const trigger = function(event) {
        if (typeof event === 'string') {
          const e = new MouseEvent(event, {
            view: window,
            bubbles: true,
            cancelable: true,
          });
          return this[0].dispatchEvent(e);
        }
        return this[0].dispatchEvent(event);
      };

      /**
       * Removes the element from the DOM.
       * (to handle with care!)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      const remove = function() {
        this[0].parentNode.removeChild(this[0]);
        return this;
      };


      // -- Main
      if (selector) {
        // Selects the first element that matches the selector(s):
        el = document.querySelector(`#${cid}`).querySelector(selector);
      } else {
        // Selects the entire 'web component':
        el = document.querySelector(`#${cid}`);
        el0 = el;
      }

      return {
        0: el,
        id: el ? el.id : null,
        _root: el0,
        // getElement: getElement,
        select,
        selectChild,
        parent,
        firstParent,
        find,
        tag,
        innerHTML,
        outerHTML,
        text,
        firstChild,
        children,
        childIndex,
        getBoundingClientRect,
        css,
        getClassList,
        hasClass,
        attr,
        on,
        off,
        trigger,
        remove,
      };
    }


    // -- Export
    $__TREE.extend($__TREE.src.component.$, { $ });

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 12, path: 'src/component/animate.js', import: [5] */
  (function() {
    /** ************************************************************************
     *
     * Performs a custom animation on a set of CSS properties.
     *
     * animate.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _swing                      defines the default easing method,
     *  . _isEasingFunction           checks if the argument is an Easing function,
     *  . _extractArgs                extracts the optional arguments of 'animate',
     *  . _run                        performs the animation,
     *  . _animate                    computes the animation parameters,
     *
     *
     * Public Static Methods:
     *  . animate                     performs the animation,
     *  . abortAnimation              aborts a running animation,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Defines the default easing method.
     *
     * @function (arg1, arg2, arg3, arg4)
     * @private
     * @param {Number}          the current lapse time,
     * @param {Number}          the initial CSS property value,
     * @param {Number}          the difference between the final and the initial value,
     * @param {Number}          the animation duration,
     * @returns {Number}        returns the value of the CSS property at the current
     * @since 0.0.0             lapse time,
     */
    /* eslint-disable no-mixed-operators */
    function _swing(t, b, c, d) {
      return c * (0.5 - Math.cos(t / d * Math.PI) / 2) + b;
    } /* eslint-enable no-mixed-operators */

    /**
     * Checks if the passed-in argument is an Easing function.
     *
     * @function (arg1)
     * @private
     * @param {...}             the argument to analyse,
     * @returns {Boolean}       returns true if the argument is an easing function,
     * @since 0.0.0
     */
    function _isEasingFunction(fn) {
      if (typeof fn === 'function'
        && (fn.name === 'linear'
            || fn.name === 'swing'
            || fn.name.startsWith('easeIn')
            || fn.name.startsWith('easeOut')
        )
      ) {
        return true;
      }
      return false;
    }

    /**
     * Extracts the optional arguments of 'animate'.
     *
     * @function (arg1, arg2, arg3)
     * @private
     * @param {?}               duration, easing or callback,
     * @param {?}               easing or callback,
     * @param {Object}          the function to call at completion,
     * @returns {Object}        returns an object with the properties duration,
     *                          easing, and callback,
     * @since 0.0.0
     */
    function _extractArgs(...args) {
      const op1 = args[0]
          , op2 = args[1]
          , op3 = args[2]
          ;

      let nargs
        , duration
        , easing
        , callback
        ;

      // How many optional arguments?
      if (!op1 && !op2 && !op3) {
        nargs = 0;
      } else if (op1 && !op2 && !op2) {
        nargs = 1;
      } else if (op1 && op2 && !op3) {
        nargs = 2;
      } else {
        nargs = 3;
      }

      switch (nargs) {
        case 0:
          break;

        case 1:
          if (_.isNumber(op1) || op1 === 'fast' || op1 === 'slow') {
            duration = op1;
          } else if (_.isString(op1) || _isEasingFunction(op1)) {
            easing = op1;
          } else if (_.isFunction(op1)) {
            callback = op1;
          }
          break;

        case 2:
          if (_.isNumber(op1) || op1 === 'fast' || op1 === 'slow') {
            duration = op1;
            if (_.isString(op2) || _isEasingFunction(op2)) {
              easing = op2;
            } else if (_.isFunction(op2)) {
              callback = op2;
            }
          } else if (_.isString(op1) || _isEasingFunction(op1)) {
            easing = op1;
            if (_.isFunction(op2)) {
              callback = op2;
            }
          }
          break;

        case 3:
          if (_.isNumber(op1) || op1 === 'fast' || op1 === 'slow') {
            duration = op1;
          }
          if (_.isString(op2) || _isEasingFunction(op2)) {
            easing = op2;
          }
          if (_.isFunction(op3)) {
            callback = op3;
          }
          break;

        default:
          break;
      }

      return {
        duration,
        easing,
        callback,
      };
    }

    /**
     * Updates dynamically the CSS properties from their initial value to their final.
     *
     * Nota:
     * By default, the property values number aatached to 'component.state'.
     * Sometimes, the value is deeper in the path (for instance
     * component.state.xxx.yyy). In this case, you need to add a property '$rpath'
     * with the value 'xxx.yyy'. The absolute path is computed by adding this
     * relative path to 'component.state' (component.state[xxx][yyy]).
     *
     * @function (arg1, arg2, arg3, arg4, arg5, arg6)
     * @private
     * @param {Object}          the given node,
     * @param {Object}          the CSS properties to update,
     * @param {Function}        the easing method,
     * @param {Number}          the animation duration,
     * @param {Number}          the animation step,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _run(component, properties, easing, duration, delay, callback) {
      const keys = Object.keys(properties);
      const rpath = properties.$rpath !== undefined ? properties.$rpath.split('.') : [];
      const index = keys.indexOf('$rpath');
      const props = {};
      const interstate = {};
      let lapseOfTime = 0
        , initial
        , value
        ;

      // Does the property '$rpath' exist?
      if (index > -1) {
        // Ok. remove it from 'keys'
        keys.splice(index, 1);
      }
      // Compute the absolute path to the property with '$rpath'
      let $path = component.state;
      rpath.forEach((item) => { $path = $path[item]; });

      // Compute easing parameters:
      keys.forEach((key) => {
        initial = parseFloat($path[key], 10);
        props[key] = {
          initial: parseFloat($path[key], 10),
          change: parseFloat(properties[key], 10) - initial,
          // suffix: properties[key].replace(/[0-9.]/g, ''),
          suffix: _.isString(properties[key])
            ? properties[key].replace(/[0-9.]/g, '')
            : '',
        };
      });

      // Execute easing:
      const timer = setInterval(() => {
        // easing:
        for (let i = 0; i < keys.length; i++) {
          value = easing(
            lapseOfTime,
            props[keys[i]].initial,
            props[keys[i]].change,
            duration,
          );
          interstate[keys[i]] = value + props[keys[i]].suffix;
        }

        // Reconcile component template and DOM:
        if (index > -1) {
          const ikeys = Object.keys(interstate);
          ikeys.forEach((key) => { $path[key] = interstate[key]; });
          component.$setState({});
        } else {
          component.$setState(interstate);
        }
        lapseOfTime += delay;
        if (lapseOfTime > duration) {
          clearInterval(timer);
          if (callback) callback();
        }
      }, delay);

      return timer;
    }

    /**
     * computes the animation parameters.
     *
     * @function (properties [, duration ] [, easing ] [, complete ])
     * @private
     * @param {Object}          an object of CSS properties,
     * @param {Number}          define how long the animation run,
     * @param {Easing}          the easing animation method,
     * @param {Function}        the function to call at completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _animate(component, properties, ...args) {
      const DTIME = 400
          , FAST  = 200
          , SLOW  = 600
          , INC   = 10
          , delay = INC
          ;

      // Is the argument properties an object?
      if (!_.isLiteralObject(properties)) {
        return [null, null];
      }

      // Extract the optional arguments:
      const argu = _extractArgs(...args);

      // Set the duration:
      const duration = _.isNumber(argu.duration) && argu.duration > 0
        ? argu.duration
        : (function(arg) {
          if (arg === 'fast') return FAST;
          if (arg === 'slow') return SLOW;
          return DTIME;
        }(argu.duration));

      // Set the easing (swing only for the time being):
      const easing = !argu.easing || _.isString(argu.easing) ? _swing : argu.easing;

      // Set the callback:
      const callback = argu.callback ? argu.callback : null;

      // Run the animation:
      const timer = _run(component, properties, easing, duration, delay, callback);
      return [timer, callback];
    }


    // -- Public Static Methods ------------------------------------------------

    const Anim = {

      /**
       * Performs a custom animation on a set of CSS properties.
       *
       * @method (properties [, duration ] [, easing ] [, complete ])
       * @public
       * @param {Object}        an object of CSS properties,
       * @param {Number}        define how long the animation run,
       * @param {Easing}        the easing animation method,
       * @param {Function}      the function to call at completion,
       * @returns {}            -,
       * @since 0.0.0
       */
      animate(component, properties, ...args) {
        return _animate(component, properties, ...args);
      },

      /**
       * Aborts a running animation.
       *
       * @method (arg1, [arg2])
       * @public
       * @param {Object}        the animation timer,
       * @param {Function}      the function to call at completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      abortAnimation(timer, callback) {
        if (timer) clearInterval(timer);
        if (callback) callback();
        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.animate, Anim);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 13, path: 'src/component/add.js', import: [14] */
  (function() {
    /** ************************************************************************
     *
     * Adds a child to a component.
     *
     * add.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _fireEvents                 executes the child component method events,
     *  . _attachMess                 attaches the messenger to the child component,
     *  . _attachChild                attaches a child to the passed-in component,
     *  . _insert                     inserts a child component,
     *
     *
     * Public Static Methods:
     *  . prepend                     adds a component as the first child,
     *  . append                      adds a component as the last child,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const R = $__TREE.src.component.render;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Executes the child component method events.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the component,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _fireChildEvents(co) {
      // Processes recursively cList to fire child events.
      if (co._cList) {
        const keys = Object.keys(co._cList);
        for (let i = 0; i < keys.length; i++) {
          co._cList[keys[i]].events();
          _fireChildEvents(co._cList[keys[i]]);
        }
      }
    }

    /**
     * Attaches the messenger to the child component.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the component,
     * @param {Object}          the messenger,
     * @returns {}              -,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _attachMess(co, mess) {
      if (mess) {
        co._mess = mess;

        if (co._cList) {
          const keys = Object.keys(co._cList);
          for (let i = 0; i < keys.length; i++) {
            co._cList[keys[i]]._mess = mess;
            _attachMess(co._cList[keys[i]], mess);
          }
        }
      }
    }
    /* eslint-enable no-param-reassign */

    /**
     * Attaches a child to the passed-in component.
     *
     * @function (arg1, arg2, arg3, arg4, arg5, arg6)
     * @private
     * @param {Object}          the component,
     * @param {Boolean}         the position of the child component,
     * @param {String}          the child component tag,
     * @param {Function}        the child component,
     * @param {Object}          the child component state properties,
     * @param {Object}          the child component properties,
     * @returns {}              -,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _attachChild(co, prepend, tag, child, state, props) {
      const c = child(state, props);
      c._tag = tag;

      if (!co._cList) co._cList = {};
      if (!co.children) co.children = {};
      co._cList[c._tag.replace(/[^a-zA-z0-9]/g, '')] = c;
      co.children[tag] = { fn: child, state, props };
      if (prepend) {
        if (!co._prepend) co._prepend = [];
        co._prepend.push(tag);
      } else {
        if (!co._append) co._append = [];
        co._append.push(tag);
      }
    }
    /* eslint-enable no-param-reassign */

    /**
     * Inserts a child component.
     *
     * @function (arg1, arg2, arg3, arg4, arg5)
     * @private
     * @param {Object}          the component,
     * @param {Boolean}         the position of the child component,
     * @param {String}          the child component tag,
     * @param {Function}        the child component,
     * @param {Object}          the child component state and props properties,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _insert(co, prepend, ...args) {
      const [tag, child, options] = args
          , opts = options || {}
          ;

      // Links the child to the parent component.
      _attachChild(co, prepend, tag, child, opts.state, opts.props);

      // Renders the child component and its own childs if any.
      // This operation fills _cList, adds an unique id to the child component
      // and its own children.
      // Attaches the messenger object if any.
      const c = co.$getChild(tag);
      R.render(c);
      _attachMess(c, co._mess);

      // Now that the child component is linked to its parent, we can 'diffs'
      // the component with its DOM counterpart. This operation inserts the
      // child component to the DOM.
      co.$setState({});

      // And finally, we have to run the 'events' method to attach the DOM
      // events to this child component and its own childs if any.
      c.events();
      _fireChildEvents(c);
    }


    // -- Public Static Methods ------------------------------------------------

    const Add = {

      /**
       * Adds a component as the first child,
       *
       * @method (arg1, ...args)
       * @public
       * @param {Object}        the component,
       * @param {...}           the child parameters,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      prepend(co, ...args) {
        _insert(co, true, ...args);
        return this;
      },

      /**
       * Adds a component as the last child,
       *
       * @method (arg1, ...args)
       * @public
       * @param {Object}        the component,
       * @param {...}           the child parameters,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      append(co, ...args) {
        _insert(co, false, ...args);
        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.add, Add);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 14, path: 'src/component/render.js', import: [5, 6] */
  (function() {
    /** ************************************************************************
     *
     * Implements the _renderer method.
     *
     * render.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _format                     formats the children object,
     *  . _formatTemplate             returns the template converted to an unique el,
     *  . _render                     renders the component and its children,
     *  . _prepend                    adds the child tag to the component as first child,
     *  . _append                     adds the child tag to the component as last child,
     *  . _reRender                   renders again the passed-in component,
     *  . _childRender                renders the children of the passed-in component,
     *
     *
     * Public Static Methods:
     *  . render                      renders the component and its children,
     *  . reRender                    renders an existing component and its children,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;
    const Hyper = $__TREE.src.component.hyperscript;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Formats the children object.
     *
     * Nota:
     * it returns: { tag1: { fn: function, state: ..., props: ... }, tag2: {...}, ... }
     *
     * @function (arg1)
     * @private
     * @param {Object}          the children object,
     * @returns {Object}        returns the formated children object,
     * @since 0.0.0
     */
    function _format(children) {
      if (!_.isLiteralObject(children)) {
        return {};
      }

      const newc = {};
      const childs = Object.keys(children);
      let child;
      for (let i = 0; i < childs.length; i++) {
        child = childs[i];

        if (_.isFunction(children[child])) {
          // is { tag: function }
          newc[child] = {
            fn: children[child],
            state: null,
            props: null,
          };
        } else if (_.isLiteralObject(children[child])
            && _.isFunction(children[child].fn)) {
          // is { tag: { fn: function, state: ..., props: ... }}
          newc[child] = {
            fn: children[child].fn,
            state: _.isLiteralObject(children[child].state)
              ? children[child].state
              : null,
            props: _.isLiteralObject(children[child].props)
              ? children[child].props
              : null,
          };
        } else {
          newc[child] = {
            fn: null,
            state: null,
            props: null,
          };
          /* eslint-disable-next-line no-console */
          console.log('warning: this component list is invalid. key "c" is missing!');
        }
      }

      return newc;
    }

    /**
     * Returns the template converted to an unique element.
     *
     * @function (arg1, arg2)
     * @private
     * @param {XMLString}       the template of the component,
     * @param {Number}          the id of the component,
     * @returns {Object}        returns the formated template,
     * @since 0.0.0
     */
    function _formatTemplate(xml, id) {
      const node = document.createElement('div');
      node.innerHTML = xml;

      if (node.children.length > 1) {
        return [`<div id="${id}">${xml}</div>`, true];
      }

      const firstChild = node.firstElementChild;
      if (!firstChild) {
        return [`<div id="${id}"></div>`, true];
      }

      const tag = firstChild.tagName.toLocaleLowerCase();
      if (tag !== 'div' && tag !== 'header' && tag !== 'footer') {
        return [`<div id="${id}">${xml}</div>`, true];
      }

      if (tag === 'div') {
        return [xml.replace(/^\s*<div/, `<div id="${id}"`), false, 'div'];
      }

      if (tag === 'header') {
        return [xml.replace(/^\s*<header/, `<header id="${id}"`), false, 'header'];
      }

      return [xml.replace(/^\s*<footer/, `<footer id="${id}"`), false, 'footer'];
    }

    /**
     * Renders the component and its children.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the component object,
     * @returns {XMLString}     returns the XMLString representation,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _render(co) {
      let xml
        , t
        ;

      // Render the component and check if it is an hyperscript:
      xml = co._render(co.state, co.props);
      if (_.isLiteralObject(xml) && _.isString(xml.nodeName)) {
        // This is an hyperscript object. We need to convert it to a serialized
        // node:
        co.children = {};
        xml = Hyper.render(xml, co.children);
      }

      // Add an unique id to this component:
      // A template must be an unique div, header, footer element with or without
      // child. If it isn't the case, we surround it by a 'div' element.
      const [s, addDiv, tagName] = _formatTemplate(xml, co.id);
      t = s;
      co._tdiv = addDiv ? 'div' : null;
      co._ttag = tagName || null;

      // Has this component children?
      if (co.children) {
        // This component includes components, render them:
        // Format children as this: { tag : { fn: function, state: ..., props: ... }}
        co.children = _format(co.children);
        co._cList = {};
        const ctags = Object.keys(co.children);
        let tag;
        let c;
        for (let i = 0; i < ctags.length; i++) {
          tag = ctags[i];
          if (_.isFunction(co.children[tag].fn)) {
            // Instantiate the child by passing the state and props:
            c = co.children[tag].fn(co.children[tag].state, co.children[tag].props);
            c._tag = tag;
            // Replace the children tag by its rendered template:
            t = t.replace(tag, c._renderer());
            // Save the children object in a list:
            co._cList[tag.replace(/[^a-zA-z0-9]/g, '')] = c;
          } else {
            /* eslint-disable-next-line no-console */
            console.log(`warning: there is no component associated to this tag: ${tag}!`);
          }
        }
      }

      // Returns the XMLString representation.
      return t;
    }
    /* eslint-enable no-param-reassign */

    /**
     * Adds the child tag to the component as the first child.
     *
     * @function (arg1, arg2)
     * @private
     * @param {XMString}        the component XMLString,
     * @param {HTML}            the child tag,
     * @returns {XMLString}     returns the XMLString including the child tag,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _prepend(xml, tag) {
      xml = xml.trim();
      const head = xml.slice(0, xml.indexOf('>') + 1);
      const trail = xml.slice(xml.indexOf('>') + 1);
      return `${head}${tag}${trail}`;
    }
    /* eslint-enable no-param-reassign */

    /**
     * Adds the child tag to the component as the last child.
     *
     * @function (arg1, arg2)
     * @private
     * @param {XMString}        the component XMLString,
     * @param {HTML}            the child tag,
     * @returns {XMLString}     returns the XMLString including the child tag,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _append(xml, tag) {
      xml = xml.trim();
      const head = xml.slice(0, xml.lastIndexOf('</'));
      const trail = xml.slice(xml.lastIndexOf('</'));
      return `${head}${tag}${trail}`;
    }
    /* eslint-enable no-param-reassign */

    /**
     * Renders again the passed-in component.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the component object,
     * @returns {XMLString}     returns the XMLString representation,
     * @since 0.0.0
     */
    function _reRender(co) {
      let xml = co._render(co.state, co.props);
      if (_.isLiteralObject(xml) && _.isString(xml.nodeName)) {
        xml = Hyper.render(xml, {});
      }
      [xml] = _formatTemplate(xml, co.id);

      if (_.isArray(co._prepend)) {
        for (let i = 0; i < co._prepend.length; i++) {
          xml = _prepend(xml, co._prepend[i]);
        }
        return xml;
      }

      if (_.isArray(co._append)) {
        for (let i = 0; i < co._append.length; i++) {
          xml = _append(xml, co._append[i]);
        }
        return xml;
      }

      return xml;
    }

    /**
     * Renders the children of the passed-in component.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the parent component object,
     * @param {XMLString}       the parent component HTML representation,
     * @returns {XMLString}     returns the XMLString representation,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _childRender(co, xml) {
      if (co._cList) {
        const childs = Object.keys(co._cList);
        for (let i = 0; i < childs.length; i++) {
          const child = co._cList[childs[i]];
          xml = _childRender(child, xml.replace(child._tag, _reRender(child)));
          child.onChange();
        }
      }

      return xml;
    }
    /* eslint-enable no-param-reassign */


    // -- Public Static Methods ------------------------------------------------

    const Render = {

      /**
       * Renders the component and its children.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the component object,
       * @returns {XMLString}   returns the XMLString representation,
       * @since 0.0.0
       */
      render(co) {
        return _render(co);
      },

      /**
       * Renders an existing component and its children.
       *
       * Nota:
       * This method differs from the previous one as it regenerates the XMLString
       * of an existing component only (without creating the component).
       *
       * @method (arg1)
       * @public
       * @param {Object}        the component object,
       * @returns {XMLString}   returns the XMLString representation,
       * @since 0.0.0
       */
      reRender(co) {
        return _childRender(co, _reRender(co));
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.render, Render);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 15, path: 'src/component/setstate.js', import: [7, 14] */
  (function() {
    /** ************************************************************************
     *
     * Updates state values and updates the modified DOM elements using 'diff'.
     *
     * setstate.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _setState                   updates state value(s),
     *
     *
     * Public Static Methods:
     *  . setState                    updates state value(s),
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const D = $__TREE.src.component.diffing;
    const R = $__TREE.src.component.render;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Updates state value(s).
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the component object,
     * @param {Object}          the state object,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _setState(component, params) {
      const { state } = component
          , keys = Object.keys(params)
          ;

      // Update the state property:
      for (let i = 0; i < keys.length; i++) {
        state[keys[i]] = params[keys[i]];
      }

      // Rerender the component and its child:
      const xml = R.reRender(component);

      // Parse all the children and see if they are differences and update only
      // the dom elements that need to be updated.
      D.diff(D.stringToHTML(xml), component.$()[0]);
    }


    // -- Public Static Methods ------------------------------------------------

    const State = {

      /**
       * Updates state value(s).
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}          the component object,
       * @param {Object}          the state object,
       * @returns {}              -,
       * @since 0.0.0
       */
      setState(component, params) {
        _setState(component, params);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.setstate, State);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 16, path: 'src/component/util.js', import: [5] */
  (function() {
    /** ************************************************************************
     *
     * A set of utility functions for View.Component.
     *
     * util.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _getList                    processes the children list,
     *  . _search                     searches for the matching child,
     *  . _remove                     removes the component's child,
     *
     *
     * Public Static Methods:
     *  . getChildren                 returns the children list,
     *  . getChild                    returns the child matching the given identity,
     *  . removeChild                 removes the component's child,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.lib;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Processes the children list.
     *
     * @function (arg1)
     * @private
     * @param {Object}          the parent object,
     * @returns {Array}         returns the child list,
     * @since 0.0.0
     */
    function _getList(co) {
      const keys = Object.keys(co._cList)
          , list = []
          ;

      for (let i = 0; i < keys.length; i++) {
        list.push({
          id: co._cList[keys[i]].id,
          name: co._cList[keys[i]].name,
        });
      }
      return list;
    }

    /**
     * Searches for the child having the passed-in identity.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the parent object,
     * @param {String}          the child identity (tag, id or name),
     * @returns {Object}        returns the child object or null,
     * @since 0.0.0
     */
    // function _search(co, ident) {
    //   if (!co._cList) return null;
    //
    //   // Processes recursively cList to find a matching child.
    //   const keys = Object.keys(co._cList);
    //   let key;
    //   for (let i = 0; i < keys.length; i++) {
    //     key = keys[i];
    //     if (ident === co._cList[key]._tag
    //       || ident === co._cList[key].id
    //       || ident === co._cList[key].name) {
    //       return co._cList[key];
    //     }
    //     const child = _search(co._cList[key], ident);
    //     if (child) return child;
    //   }
    //   return null;
    // }
    function _search(co, ident) {
      if (!co._cList) return { parent: co, child: null };

      // Processes recursively cList to find a matching child.
      const keys = Object.keys(co._cList);
      let key;
      for (let i = 0; i < keys.length; i++) {
        key = keys[i];
        if (ident === co._cList[key]._tag
          || ident === co._cList[key].id
          || ident === co._cList[key].name) {
          return { parent: co, child: co._cList[key] };
        }
        const res = _search(co._cList[key], ident);
        if (res.child) return res;
      }
      return { parent: co, child: null };
    }

    /**
     * Removes the passed-in child from the component.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object}          the parent object,
     * @param {String}          the child identity (tag, id or name),
     * @returns {Boolean}       returns true or false,
     * @since 0.0.0
     */
    /* eslint-disable no-proto */
    function _remove(co, ident) {
      const r = _search(co, ident);
      if (!r.child) return false;

      const tag = r.child._tag;
      const stag = r.child._tag.replace('<', '').replace('/>', '').trim();

      // 1. Remove the component child from DOM:
      r.child.$().remove();

      // 2. Remove all own and inherited properties from the component child:
      Object.getOwnPropertyNames(r.child).forEach((key) => { delete r.child[key]; });
      r.child.__proto__ = {};

      // 3. Remove all own and inherited properties from component child Constructor:
      Object.getOwnPropertyNames(r.parent.children[tag]).forEach((key) => {
        delete r.parent.children[tag][key];
      });
      r.parent.children[tag].__proto__ = {};

      // 4. Remove all traces from parent:
      delete r.parent._cList[stag];
      delete r.parent.children[tag];
      if (r.parent._append) {
        r.parent._append = r.parent._append.filter((item) => item !== tag);
      }
      if (r.parent._prepend) {
        r.parent._prepend = r.parent._prepend.filter((item) => item !== tag);
      }

      return true;
    }
    /* eslint-enable no-proto */


    // -- Public Static Methods ------------------------------------------------

    const Util = {

      /**
       * Returns the children list.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the parent component object,
       * @returns {Array}       returns the children list,
       * @since 0.0.0
       */
      getChildren(co) {
        return co._cList ? _getList(co) : null;
      },

      /**
       * Returns the child component matching the passed-in identity.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the parent component object,
       * @param {String}        the child identity (tag, id or name),
       * @returns {Object}      returns the matching child component,
       * @since 0.0.0
       */
      getChild(co, ident) {
        return ident && _.isString(ident) ? _search(co, ident).child : null;
      },

      /**
       * Removes the component's child.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the parent component object,
       * @param {String}        the child identity (tag, id or name),
       * @returns {Boolean}     returns true or false,
       * @since 0.0.0
       */
      removeChild(co, ident) {
        return ident && _.isString(ident) ? _remove(co, ident) : false;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.component.util, Util);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());


  // Returns the library name:
  return $__TREE.src.rview;
}));
